package Analizadores;
import Programa.HTMLTable;
import java_cup.runtime.*;
import java.util.*;
import Analizadores.*;

action code {:

public void hola_mundo() {
    System.out.println("Hola Mundo");
}

HashMap<String, ArrayList<SymbolObject>> tablasSimbolos = new HashMap<String, ArrayList<SymbolObject>>();
String hash = "";
ArrayList<Funcion> funciones = new ArrayList<Funcion>();

ArrayList<ExpType> tipos_arit = new ArrayList<ExpType>();
ArrayList<ExpType> tipos_rel = new ArrayList<ExpType>();
ArrayList<ExpType> tipos_log = new ArrayList<ExpType>();
ArrayList<ExpType> tipos_u = new ArrayList<ExpType>();

public void cargarTiposOperaciones() {
    tipos_arit.add(ExpType.INT);
    tipos_arit.add(ExpType.FLOAT);
    tipos_rel.add(ExpType.INT);
    tipos_rel.add(ExpType.FLOAT);
    tipos_rel.add(ExpType.BOOL);
    tipos_log.add(ExpType.BOOL);
    tipos_u.add(ExpType.INT);
}


public ExpType validarExp(ExpType tipo1, ExpType tipo2, ArrayList<ExpType> tipos, String operador) {
    if(tipo1 != tipo2) {
        System.out.println("Error semantico en la linea " + lex.getLine() + " columna " + lex.getColumn() + " los tipos de la expresion " + tipo1.toString() + " y " + tipo2.toString() + " no coinciden con el operador " + operador);
        return ExpType.ERROR;
    }
    if(!tipos.contains(tipo1)) {
        System.out.println("Error semantico en la linea " + lex.getLine() + " columna " + lex.getColumn() + " los tipos de la expresion " + tipo1.toString() + " y " + tipo2.toString() + " no coinciden con el operador " + operador);
        return ExpType.ERROR;
    }
    return tipo1;
}

public ExpType validarExpU(ExpType tipo, String operador) {
    if(!tipos_u.contains(tipo)) {
        System.out.println("Error semantico en la linea " + lex.getLine() + " columna " + lex.getColumn() + " el tipo de la expresion " + tipo.toString() + " no coincide con el operador " + operador);
        return ExpType.ERROR;
    }
    return tipo;
}


public void createSymbolTable() {
    ArrayList<String[]> rows = new ArrayList<String[]>();

    for (String key: tablasSimbolos.keySet()) {
        for (SymbolObject val: tablasSimbolos.get(key)) {
            String[] row = new String[]{key, val.getTipoEntrada(), val.getNombre(), val.getTipoDato()};
            rows.add(row);
        }
    }
    // Instancia la clase para crear la tabla de simbolos
    HTMLTable tableGenerator = new HTMLTable();
    // Crea la tabla con los resultados
    String table = tableGenerator.createSymTable(rows);
    // Escribe el archivo HTML
    String outputFile = "src/main/java/Programa/tablaSim.html";
    tableGenerator.createHTMLFile(table, outputFile);
    System.out.println("Tabla de Simbolos creada en: " + outputFile);

}

public void printSymbolTable() {
    
    for (String key: tablasSimbolos.keySet()) {
        System.out.println("Tabla de simbolos: " + key);
        System.out.println("Valores: ");
        for (SymbolObject val: tablasSimbolos.get(key)) {
            System.out.println(val.toString());
        }
    }
}


public void addHash(String newHash) {
    hash = newHash;
    tablasSimbolos.put(newHash, new ArrayList<SymbolObject>());

}
public void addSymbol(SymbolObject symbol) {
    tablasSimbolos.get(hash).add(symbol);
}

public Funcion buscarFuncion(String nombre) {
    for(Funcion funcion: funciones) {
        if(funcion.getNombre().equals(nombre)) {
            return funcion;
        }
    }
    return null;
} 

public Funcion funcionActual() {
    return funciones.get(funciones.size() - 1);
}

public ExpType getTipoVar(String nombre, boolean err){
    for(SymbolObject symbol: tablasSimbolos.get(hash)) {
        if(symbol.getNombre().equals(nombre)) {
            return Expresion.ExpType(symbol.getTipoDato());
        }
    }
    if(err) {
        System.out.println("Error semantico en la linea " + lex.getLine() + " columna " + lex.getColumn() + " la variable " + nombre + " no ha sido declarada en el alcance actual");
    }
    return ExpType.ERROR;
}
:}


// Crea el parser y lo conecta al scanner (JFlex con expresiones regulares)
parser code {:
    Lexer lex;

    public Parser(Lexer lex) {
        this.lex=lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }
    
    @Override
    public void syntax_error(Symbol token) {
        if (token.value == null) {
            return;
        }
        System.out.println("Error de sintaxis en la linea " + token.left + " columna " + token.right + ": " + token.value);
        System.out.println("Continuando con el parsing");
    }
    
    @Override
    public void unrecovered_syntax_error(Symbol token) throws java.lang.Exception {
        throw new Exception("Error de sintaxis irrecuperable en la linea " + token.left + " columna " + token.right + ": " + token.value);
    }
:}

// Escanear los tokens
scan with {: return lex.next_token(); :};
init with {: :};

// Definicion de termminales (Tokens)

// Operadores arimeticos binarios
terminal suma_rudolph, resta_dasher, division_dancer;
terminal multiplicacion_prancer, modulo_vixen, potencia_comet;

// Operadores aritmeticos unarios
terminal aumentar_quien, disminuir_grinch;

// Operadores relacionales
terminal igual_twinkle, diferente_sparkle, mayor_jingle;
terminal mayor_igual_blinky, menor_fizz, menor_igual_mistle;

// Expresiones logicas
terminal and_melchor, or_gaspar, not_baltasar;

// Identificador
terminal identificador_persona;

// Funciones
terminal function_regalo;

// Tipos de datos
terminal int_noel, float_nicolas, bool_kringle, string_sinterklaas, char_pascuero;

// Literales
terminal l_string_sinterklaas, l_char_pascuero;
terminal l_int_noel, l_float_nicolas, l_true_olentzero, l_false_jesus;

// Parentesis redondos
terminal redondo_abre_cuento, redondo_cierra_cuento;

// Parentesis cuadrados
terminal cuadrado_abre_empaque, cuadrado_cierra_empaque;

// Llaves
terminal llave_abre_regalo, llave_cierra_regalo;

// Estructura de control
terminal if_elfo, elif_hada, else_duende, for_envuelve;
terminal do_hace, until_revisa, return_envia, break_corta;

// Print y read
terminal print_narra, read_escucha;

// Fin de expresion
terminal fin_regalo;

// Asignar
terminal asignar_entrega;

// Separador
terminal separador_luces;

// Main
terminal main_fiestas;

// Error
terminal err_malcriado;

// Estructura gramatical para tarea 1

// Variable
terminal local_arbol;

//Simbolo inicial
non terminal navidad;

/*
|-----------------------------------|
|        //no terminales            |
|-----------------------------------|
*/

// Tipos
non terminal tipos_noel, literales_noel;

// Arreglos
non terminal array_lista_viajes, array_elementos_destinos;  

// Expresion
non terminal expresion_regalo;

// Expresiones arimeticas
non terminal aritmeticas_regaloprin;

// Expresiones relacionales;
non terminal relacionales_regalocomprado;

// Expresiones logicas
non terminal logicas_regalomanual;

// Asignacion
non terminal asig_galleta;

// Parametros y funciones
non terminal argumento_rompope, parametro_pascua, parametros_pascua, funcion_bolsanavidena, funcion_gnomo, definir_funcion_leche, defininir_funcion_galletas;

// Llamada de funciones
non terminal llamada_funciones_nieve;

// Ciclos
non terminal for_fabrica, do_regalos;

// Condicionales
non terminal if_tamal, elif_pavo, else_chanchito;

// Bloque de codigo y return
non terminal bloque_muneco, lineas_calabaza, linea_bola_nieve, return_confite;


// Definiciones para precedencia y asociatividad
precedence left suma_rudolph, resta_dasher;
precedence left division_dancer, multiplicacion_prancer;
precedence left potencia_comet, modulo_vixen;
precedence left disminuir_grinch, aumentar_quien;
precedence left igual_twinkle, menor_fizz, mayor_jingle, mayor_igual_blinky;
precedence left menor_igual_mistle, diferente_sparkle;
precedence left and_melchor;
precedence left or_gaspar;
precedence left not_baltasar;

start with navidad;

navidad ::= funcion_bolsanavidena {: createSymbolTable();
                                     printSymbolTable();
                                     cargarTiposOperaciones();

                                     if(buscarFuncion("main") == null) {
                                        System.out.println("Error semantico: No se encontro la funcion main");
                                     }
                                     else {
                                        System.out.println("La funcion main fue encontrada");
                                     }

                                     for(Funcion funcion: funciones) {
                                        if(funcion.isRetornaAlgo() == false) {
                                            System.out.println("Error semantico: La funcion " + funcion.getNombre() + " no retorna algo valido");
                                        }
                                     }
                                   :};

// Tipos y literales
tipos_noel ::= int_noel:type {: RESULT = type; :} | float_nicolas:type {: RESULT = type; :} | bool_kringle:type {: RESULT = type; :} | string_sinterklaas:type {: RESULT = type; :} | char_pascuero:type {: RESULT = type; :};
literales_noel ::= l_string_sinterklaas:literal  {: RESULT = new Expresion(literal, ExpType.STRING); :} |
l_char_pascuero:literal {: RESULT = new Expresion(literal, ExpType.CHAR); :} |
l_int_noel:literal {: RESULT = new Expresion(literal, ExpType.INT); :} |
l_float_nicolas:literal {: RESULT = new Expresion(literal, ExpType.FLOAT); :} | 
l_true_olentzero:literal {: RESULT = new Expresion(literal, ExpType.BOOL); :} | 
l_false_jesus:literal {: RESULT = new Expresion(literal, ExpType.BOOL); :}; 

// Arreglos
array_lista_viajes ::= identificador_persona:id cuadrado_abre_empaque expresion_regalo:exp cuadrado_cierra_empaque 
    {:
    Expresion a = (Expresion)exp;
    ExpType tipo = a.getTipo();
    ExpType tipoVar = getTipoVar(id.toString(), true);
    RESULT = new Expresion("null", ExpType.ERROR);
    if(tipo != ExpType.INT) {
        System.out.println("Error semantico en la linea " + lex.getLine() + " columna " + lex.getColumn() + " el tipo de la expresion " + tipo.toString() + " no es valido");
    }
    else if(tipoVar != ExpType.INTLIST && tipoVar != ExpType.CHARLIST) {
        System.out.println("Error semantico en la linea " + lex.getLine() + " columna " + lex.getColumn() + " la variable " + id.toString() + " no es un arreglo");
    }
    else {
        RESULT = new Expresion(id.toString() + "[" + a.getValor().toString() + "]", tipoVar);
    }
    :}; // x[3]
array_elementos_destinos ::= llave_abre_regalo argumento_rompope:arg llave_cierra_regalo
    {:
    var temp = (ArrayList<Expresion>)arg;
    boolean flag = false;
    ExpType tipo = temp.get(0).getTipo();

    if(tipo != ExpType.INT && tipo != ExpType.CHAR) {
        System.out.println("Error semantico en la linea " + lex.getLine() + " columna " + lex.getColumn() + " el tipo de la expresion " + tipo.toString() + " no es valido");
        RESULT = new Expresion("null", ExpType.ERROR);
        flag = true;
    }
    for(Expresion exp: temp) {
        if(exp.getTipo() != tipo) {
            System.out.println("Error semantico en la linea " + lex.getLine() + " columna " + lex.getColumn() + " el tipo de la expresion " + exp.getTipo().toString() + " no coincide con el tipo del arreglo " + tipo.toString());
            RESULT = new Expresion("null", ExpType.ERROR);
            flag = true;
            break;  
        }
    }
    if(!flag) {
        if(tipo == ExpType.INT) {
            RESULT = new Expresion(temp, ExpType.INTLIST);
        }
        else {
            RESULT = new Expresion(temp, ExpType.CHARLIST);
        }
    }
    :}; // {3, 4, 5, 1}

// Expresion
expresion_regalo ::= literales_noel:literales 
    {: 
    RESULT = literales; 
    :} |
    identificador_persona:id_p 
    {: 
    if(getTipoVar(id_p.toString(), true) != ExpType.ERROR) {
        RESULT = new Expresion(id_p.toString(), getTipoVar(id_p.toString(), true));
    }
    else {
        RESULT = new Expresion(id_p.toString(), ExpType.ERROR);
    }
    :}| 
redondo_abre_cuento expresion_regalo:exp redondo_cierra_cuento 
    {: 
    RESULT = exp;
    :} |
logicas_regalomanual: exp
    {: 
    RESULT = exp;
    :} |
aritmeticas_regaloprin:exp 
    {:
    RESULT = exp;
    :}| 
relacionales_regalocomprado:exp 
    {:
    RESULT = exp;
    :} | 
llamada_funciones_nieve:exp 
    {:
    RESULT = exp;
    :} | 
    array_lista_viajes:arr 
    {:
    RESULT = arr;
    :};

// Operaciones aritmeticas
aritmeticas_regaloprin ::= expresion_regalo:exp1 suma_rudolph expresion_regalo:exp2
    {:
    Expresion a = (Expresion)exp1;
    Expresion b = (Expresion)exp2;
    ExpType res = validarExp(a.getTipo(), b.getTipo(), tipos_arit, "+");
    if(res != ExpType.ERROR) {
        RESULT = new Expresion(a.getValor().toString() + " + " + b.getValor().toString(), res);
    }
    else {
        RESULT = new Expresion("null", ExpType.ERROR);
    }
    :} | // x + y
expresion_regalo:exp1 resta_dasher expresion_regalo:exp2
    {:
    Expresion a = (Expresion)exp1;
    Expresion b = (Expresion)exp2;
    ExpType res = validarExp(a.getTipo(), b.getTipo(), tipos_arit, "-");
    if(res != ExpType.ERROR) {
        RESULT = new Expresion(a.getValor().toString() + " - " + b.getValor().toString(), res);
    }
    else {
        RESULT = new Expresion("null", ExpType.ERROR);
    }
    :} | // x - y
expresion_regalo:exp1 division_dancer expresion_regalo:exp2
    {:
    Expresion a = (Expresion)exp1;
    Expresion b = (Expresion)exp2;
    ExpType res = validarExp(a.getTipo(), b.getTipo(), tipos_arit, "/");
    if(res != ExpType.ERROR) {
        RESULT = new Expresion(a.getValor().toString() + " / " + b.getValor().toString(), res);
    }
    else {
        RESULT = new Expresion("null", ExpType.ERROR);
    }
    :} | // x / y
expresion_regalo:exp1 multiplicacion_prancer expresion_regalo:exp2
    {:
    Expresion a = (Expresion)exp1;
    Expresion b = (Expresion)exp2;
    ExpType res = validarExp(a.getTipo(), b.getTipo(), tipos_arit, "*");
    if(res != ExpType.ERROR) {
        RESULT = new Expresion(a.getValor().toString() + " * " + b.getValor().toString(), res);
    }
    else {
        RESULT = new Expresion("null", ExpType.ERROR);
    }
    :} | // x * y
expresion_regalo:exp1 modulo_vixen expresion_regalo:exp2
    {:
    Expresion a = (Expresion)exp1;
    Expresion b = (Expresion)exp2;
    ExpType res = validarExp(a.getTipo(), b.getTipo(), tipos_arit, "~");
    if(res != ExpType.ERROR) {
        RESULT = new Expresion(a.getValor().toString() + " ~ " + b.getValor().toString(), res);
    }
    else {
        RESULT = new Expresion("null", ExpType.ERROR);
    }
    :} | // x ~ y
expresion_regalo:exp1 potencia_comet expresion_regalo:exp2
    {:
    Expresion a = (Expresion)exp1;
    Expresion b = (Expresion)exp2;
    ExpType res = validarExp(a.getTipo(), b.getTipo(), tipos_arit, "**");
    if(res != ExpType.ERROR) {
        RESULT = new Expresion(a.getValor().toString() + " ** " + b.getValor().toString(), res);
    }
    else {

        RESULT = new Expresion("null", ExpType.ERROR);
    }
    :} | // x ** y
aumentar_quien identificador_persona:id
    {:
    ExpType res = getTipoVar(id.toString(), false);
    ExpType res2 = validarExpU(res, "++");
    if(res != ExpType.ERROR) {
        RESULT = new Expresion("++" + id.toString(), res);
    }
    else {
        System.out.println("Error semantico en la linea " + lex.getLine() + " columna " + lex.getColumn() + " la variable " + id.toString() + " no se puede aumentar");
        RESULT = new Expresion("null", ExpType.ERROR);
    }

    :} | // ++x
disminuir_grinch identificador_persona:id
    {:
    ExpType res = getTipoVar(id.toString(), false);
    ExpType res2 = validarExpU(res, "--");
    if(res != ExpType.ERROR) {
        RESULT = new Expresion("--" + id.toString(), res);
    }
    else {
        System.out.println("Error semantico en la linea " + lex.getLine() + " columna " + lex.getColumn() + " la variable " + id.toString() + " no se puede disminuir");
        RESULT = new Expresion("null", ExpType.ERROR);
    }
    :}
; // --x



// Operaciones relacionales
relacionales_regalocomprado ::= expresion_regalo:exp1 igual_twinkle expresion_regalo:exp2
    {:
    Expresion a = (Expresion)exp1;
    Expresion b = (Expresion)exp2;
    ExpType res = validarExp(a.getTipo(), b.getTipo(), tipos_rel, "==");
    if(res != ExpType.ERROR) {
        RESULT = new Expresion(a.getValor().toString() + " == " + b.getValor().toString(), ExpType.BOOL);
    }
    else {
        RESULT = new Expresion("null", ExpType.ERROR);
    }
    :} | // x == y
expresion_regalo:exp1 diferente_sparkle expresion_regalo:exp2
    {:
    Expresion a = (Expresion)exp1;
    Expresion b = (Expresion)exp2;
    ExpType res = validarExp(a.getTipo(), b.getTipo(), tipos_rel, "!=");
    if(res != ExpType.ERROR) {
        RESULT = new Expresion(a.getValor().toString() + " != " + b.getValor().toString(), ExpType.BOOL);
    }
    else {
        RESULT = new Expresion("null", ExpType.ERROR);
    }
    :} | // x != y
expresion_regalo:exp1 mayor_jingle expresion_regalo:exp2
    {:
    Expresion a = (Expresion)exp1;
    Expresion b = (Expresion)exp2;
    ExpType res = validarExp(a.getTipo(), b.getTipo(), tipos_rel, ">");
    if(res != ExpType.ERROR) {
        RESULT = new Expresion(a.getValor().toString() + " > " + b.getValor().toString(), ExpType.BOOL);
    }
    else {
        RESULT = new Expresion("null", ExpType.ERROR);
    }
    :} | // x > y
expresion_regalo:exp1 mayor_igual_blinky expresion_regalo:exp2
    {:
    Expresion a = (Expresion)exp1;
    Expresion b = (Expresion)exp2;
    ExpType res = validarExp(a.getTipo(), b.getTipo(), tipos_rel, ">=");
    if(res != ExpType.ERROR) {
        RESULT = new Expresion(a.getValor().toString() + " >= " + b.getValor().toString(), ExpType.BOOL);
    }
    else {
        RESULT = new Expresion("null", ExpType.ERROR);
    }
    :} | // x >= y
expresion_regalo:exp1 menor_fizz expresion_regalo:exp2
    {:
    Expresion a = (Expresion)exp1;
    Expresion b = (Expresion)exp2;
    ExpType res = validarExp(a.getTipo(), b.getTipo(), tipos_rel, "<");
    if(res != ExpType.ERROR) {
        RESULT = new Expresion(a.getValor().toString() + " < " + b.getValor().toString(), ExpType.BOOL);
    }
    else {
        RESULT = new Expresion("null", ExpType.ERROR);
    }
    :} | // x < y

expresion_regalo:exp1 menor_igual_mistle expresion_regalo:exp2
    {:
    Expresion a = (Expresion)exp1;
    Expresion b = (Expresion)exp2;
    ExpType res = validarExp(a.getTipo(), b.getTipo(), tipos_rel, "=<");
    if(res != ExpType.ERROR) {
        RESULT = new Expresion(a.getValor().toString() + " =< " + b.getValor().toString(), ExpType.BOOL);
    }
    else {
        RESULT = new Expresion("null", ExpType.ERROR);
    }
    :}; // x =< y

// Operaciones logicas
logicas_regalomanual ::= expresion_regalo:exp1 and_melchor expresion_regalo:exp2
    {:
    Expresion a = (Expresion)exp1;
    Expresion b = (Expresion)exp2;
    ExpType res = validarExp(a.getTipo(), b.getTipo(), tipos_log, "^");
    if(res != ExpType.ERROR) {
        RESULT = new Expresion(a.getValor().toString() + " ^ " + b.getValor().toString(), ExpType.BOOL);
    }
    else {
        RESULT = new Expresion("null", ExpType.ERROR);
    }
    :}| // x ^ y
expresion_regalo:exp1 or_gaspar expresion_regalo:exp2
    {:
    Expresion a = (Expresion)exp1;
    Expresion b = (Expresion)exp2;
    ExpType res = validarExp(a.getTipo(), b.getTipo(), tipos_log, "#");
    if(res != ExpType.ERROR) {
        RESULT = new Expresion(a.getValor().toString() + " # " + b.getValor().toString(), ExpType.BOOL);
    }
    else {
        RESULT = new Expresion("null", ExpType.ERROR);
    }
    :} | // x # y
not_baltasar expresion_regalo:exp
    {:
    Expresion a = (Expresion)exp;
    ExpType res = validarExp(a.getTipo(), ExpType.BOOL, tipos_log, "!");
    if(res != ExpType.ERROR) {
        RESULT = new Expresion("!" + a.getValor().toString(), ExpType.BOOL);
    }
    else {
        RESULT = new Expresion("null", ExpType.ERROR);
    }
    :}; // !x

// Asignacion de variables
asig_galleta ::= local_arbol tipos_noel:type identificador_persona:id 
    {: 
    if(getTipoVar(id.toString(), false) != ExpType.ERROR) {
        System.out.println("Error semantico en la linea " + lex.getLine() + " columna " + lex.getColumn() + " la variable " + id.toString() + " ya ha sido declarada");
    }
    
    else {
        SymbolObject symbol = new SymbolObject("local", type.toString(), id.toString());
        addSymbol(symbol);
    }
    :} | // local int x
local_arbol tipos_noel:type identificador_persona:id asignar_entrega expresion_regalo:exp
    {:
    if(getTipoVar(id.toString(), false) != ExpType.ERROR) {
        System.out.println("Error semantico en la linea " + lex.getLine() + " columna " + lex.getColumn() + " la variable " + id.toString() + " ya ha sido declarada");
    }
    else {
        Expresion a = (Expresion)exp;
        if(a.getTipo() != Expresion.ExpType(type.toString())) {
            System.out.println("Error semantico en la linea " + lex.getLine() + " columna " + lex.getColumn() + " el tipo de la expresion " + a.getTipo().toString() + " no coincide con el tipo de la variable " + type.toString());
        }
        else {
            SymbolObject symbol = new SymbolObject("local", type.toString(), id.toString());
            addSymbol(symbol);
        }
    }
    :} | // local int x <= 5
identificador_persona:id asignar_entrega expresion_regalo:exp 
    {:
    Expresion a = (Expresion)exp;
    ExpType tipo = getTipoVar(id.toString(), true);
    if(tipo != a.getTipo()) {
        System.out.println("Error semantico en la linea " + lex.getLine() + " columna " + lex.getColumn() + " el tipo de la expresion " + a.getTipo().toString() + " no coincide con el tipo de la variable " + tipo.toString());
    }
    :} |// x <= 5
local_arbol tipos_noel:type identificador_persona:id cuadrado_abre_empaque l_int_noel:lit cuadrado_cierra_empaque
    {:
    if(type.toString() != "int" && type.toString() != "char") {
        System.out.println("Error semantico en la linea " + lex.getLine() + " columna " + lex.getColumn() + " el tipo de la variable " + type.toString() + " no es valido");
    }
    else {
        int size = Integer.parseInt(lit.toString());
        if(size <= 0) {
            System.out.println("Error semantico en la linea " + lex.getLine() + " columna " + lex.getColumn() + " el tamano del arreglo " + size + " no es valido");
        }
        else {
            SymbolObject symbol = new SymbolObject("local", type.toString() + "[]", id.toString());
            addSymbol(symbol);
        }
    }
    :}| // local int x[5]   
local_arbol tipos_noel:type identificador_persona:id cuadrado_abre_empaque l_int_noel:lit cuadrado_cierra_empaque asignar_entrega array_elementos_destinos:arr 
    {:
    if(type.toString() != "int" && type.toString() != "char") {
        System.out.println("Error semantico en la linea " + lex.getLine() + " columna " + lex.getColumn() + " el tipo de la variable " + type.toString() + " no es valido");
    }
    else {
        Expresion a = (Expresion)arr;
        if(a.getTipo() == ExpType.ERROR){
            System.out.println("Error semantico en la linea " + lex.getLine() + " columna " + lex.getColumn() + " el tipo de la expresion " + a.getTipo().toString() + " no coincide con el tipo del arreglo " + type.toString());
        }
        else{
            ExpType tipo = Expresion.ExpType(type.toString() + "[]");
            if(a.getTipo() != tipo) {
                System.out.println("Error semantico en la linea " + lex.getLine() + " columna " + lex.getColumn() + " el tipo de la expresion " + a.getTipo().toString() + " no coincide con el tipo del arreglo " + tipo.toString());
            }
            else {
                var temp = (ArrayList<Expresion>)a.getValor();
                int size = Integer.parseInt(lit.toString());
                if(size != temp.size()) {
                    System.out.println("Error semantico en la linea " + lex.getLine() + " columna " + lex.getColumn() + " el tamano del arreglo " + size + " no coincide con el tamano del arreglo" + temp.size());
                }
                else {
                    if(getTipoVar(id.toString(), false) != ExpType.ERROR) {
                        System.out.println("Error semantico en la linea " + lex.getLine() + " columna " + lex.getColumn() + " la variable " + id.toString() + " ya ha sido declarada");
                    }
                    else {
                        SymbolObject symbol = new SymbolObject("local", type.toString() + "[]", id.toString());
                        addSymbol(symbol);
                    }
                }
            }
        }
    }
    :}| // local int x[5] <= {3, 4, 5, 1, 2}
array_lista_viajes:arr asignar_entrega expresion_regalo:exp
    {:
    Expresion a = (Expresion)arr;
    Expresion b = (Expresion)exp;
    ExpType tipoA = a.getTipo();
    ExpType tipoB = b.getTipo();
    if(tipoA != tipoB){
        System.out.println("Error semantico en la linea " + lex.getLine() + " columna " + lex.getColumn() + " el tipo de la expresion " + tipoB.toString() + " no coincide con el tipo del arreglo " + tipoA.toString());
    }
    else {
        if(tipoA == ExpType.ERROR) {
            System.out.println("Error semantico en la linea " + lex.getLine() + " columna " + lex.getColumn() + " el tipo de la expresion no es valido");
        }
    }

    :}; // x[2] <= 43

// Parametros y funciones (leche main, galletas otras)

argumento_rompope::= expresion_regalo:exp {: 
    ArrayList<Expresion> temp = new ArrayList<>();
    temp.add((Expresion)exp); 
    RESULT = temp; :} | 
argumento_rompope:arg separador_luces expresion_regalo:exp {: 
    ArrayList<Expresion> temp = (ArrayList<Expresion>)arg; 
    temp.add((Expresion)exp); 
    RESULT = temp; :}; // 3, 4, 5, 1

parametro_pascua ::= tipos_noel:type identificador_persona:id {: SymbolObject symbol = new SymbolObject("param", type.toString(), id.toString());
                                                                 addSymbol(symbol);
                                                               :};
parametros_pascua ::= parametro_pascua | parametros_pascua separador_luces parametro_pascua; // 4, 5, 1

funcion_bolsanavidena ::= funcion_gnomo | funcion_bolsanavidena funcion_gnomo; // funciones del programa

funcion_gnomo ::= definir_funcion_leche bloque_muneco | defininir_funcion_galletas bloque_muneco; // funciones con bloque de codigo

// Aqui se definen los hash segun la funcion
// Arreglar dividir la estructura de la funcion de los parametros
definir_funcion_leche ::= tipos_noel:type function_regalo main_fiestas:main redondo_abre_cuento redondo_cierra_cuento  {: addHash("main");
                                                                                                                               SymbolObject symbol = new SymbolObject("function", type.toString(), "main");
                                                                                                                               addSymbol(symbol);
                                                                                                                             :}| // int func main ()

                          tipos_noel:type function_regalo main_fiestas:main redondo_abre_cuento parametros_pascua:param redondo_cierra_cuento  {: addHash("main");
                                                                                                                                                 SymbolObject symbol = new SymbolObject("function", type.toString(), "main");
                                                                                                                                                 addSymbol(symbol);
                                                                                                                                                :}; // int func main (3, 4) 

defininir_funcion_galletas ::= tipos_noel:type function_regalo identificador_persona:id redondo_abre_cuento redondo_cierra_cuento  {: addHash(id.toString());
                                                                                                                                           SymbolObject symbol = new SymbolObject("function", type.toString(), id.toString());
                                                                                                                                           addSymbol(symbol);
                                                                                                                                         :} | // int func myfunc ()
                               tipos_noel:type function_regalo identificador_persona:id redondo_abre_cuento parametros_pascua:param redondo_cierra_cuento  {: addHash(id.toString());
                                                                                                                                                             SymbolObject symbol = new SymbolObject("function", type.toString(), id.toString());
                                                                                                                                                             addSymbol(symbol);
                                                                                                                                                           :}; // int func myfunc (3, 4)

// Llamada de funciones (main, otras, read, print)
llamada_funciones_nieve ::= main_fiestas redondo_abre_cuento redondo_cierra_cuento | // main sin parametros
                            main_fiestas redondo_abre_cuento argumento_rompope redondo_cierra_cuento | // main con parametros
                            identificador_persona redondo_abre_cuento redondo_cierra_cuento | // funcion sin parametros
                            identificador_persona redondo_abre_cuento argumento_rompope redondo_cierra_cuento | // funcion con parametros
                            print_narra redondo_abre_cuento argumento_rompope redondo_cierra_cuento | //print(abc)
                            read_escucha redondo_abre_cuento redondo_cierra_cuento | //read()
                            read_escucha redondo_abre_cuento identificador_persona redondo_cierra_cuento; //read(id)



// Ciclos (for. do until, while)

// for = for (local int x <= 0| i | j) {}

for_fabrica ::= for_envuelve redondo_abre_cuento asig_galleta fin_regalo expresion_regalo:exp fin_regalo expresion_regalo fin_regalo redondo_cierra_cuento bloque_muneco
    {:
    Expresion a = (Expresion)exp;
    ExpType tipo = a.getTipo();
    if(tipo != ExpType.BOOL) {
        System.out.println("Error semantico en la linea " + lex.getLine() + " columna " + lex.getColumn() + " el tipo de la expresion " + tipo.toString() + " no es valido porque no es booleano");
    }
    :};

// do until = do {} until (x)

do_regalos ::= do_hace bloque_muneco until_revisa redondo_abre_cuento expresion_regalo:exp redondo_cierra_cuento
    {:
    Expresion a = (Expresion)exp;
    ExpType tipo = a.getTipo();
    if(tipo != ExpType.BOOL) {
        System.out.println("Error semantico en la linea " + lex.getLine() + " columna " + lex.getColumn() + " el tipo de la expresion " + tipo.toString() + " no es valido porque no es booleano");
    }
    :};

// Condicionales (if, else, elif, switch, case)

if_tamal ::= if_elfo redondo_abre_cuento expresion_regalo:exp redondo_cierra_cuento bloque_muneco | // if (x) {} else {}
    if_elfo redondo_abre_cuento expresion_regalo redondo_cierra_cuento bloque_muneco elif_pavo | // if (x) {} elif (y) {} ...
    if_elfo redondo_abre_cuento expresion_regalo redondo_cierra_cuento bloque_muneco elif_pavo else_chanchito; // if (x) {} elif (y) {} else {} 

elif_pavo ::= elif_hada redondo_abre_cuento expresion_regalo redondo_cierra_cuento bloque_muneco | // elif (x) {}
              elif_hada redondo_abre_cuento expresion_regalo redondo_cierra_cuento bloque_muneco elif_pavo; // elif (x) {} elif (y) {}...

else_chanchito ::= else_duende bloque_muneco;

// Bloques de codigo

bloque_muneco ::= llave_abre_regalo lineas_calabaza llave_cierra_regalo | llave_abre_regalo llave_cierra_regalo;

lineas_calabaza ::= linea_bola_nieve | lineas_calabaza linea_bola_nieve;

linea_bola_nieve ::= asig_galleta fin_regalo | 
expresion_regalo fin_regalo |
return_confite fin_regalo |
break_corta fin_regalo |
if_tamal fin_regalo|
do_regalos fin_regalo|
for_fabrica fin_regalo; //do, for, if

// Return

return_confite::= return_envia | return_envia expresion_regalo:exp {:
    ExpType tipo = ((Expresion)exp).getTipo();
    ExpType tipoFuncion = funcionActual().getRetorno();
    if(tipo != tipoFuncion) {
        System.out.println("Error semantico en la linea " + lex.getLine() + " columna " + lex.getColumn() + "el tipo de retorno de la funcion " + tipoFuncion.toString() + " no coincide con el tipo de la expresion" + tipo.toString());
    }
    else{
        funcionActual().setRetornaAlgo(true);
    }
:}; // return x | return

